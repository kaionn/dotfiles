#!/usr/bin/env node
/**
 * Claude Code Session Logger
 *
 * SessionEnd ãƒ•ãƒƒã‚¯ã§å®Ÿè¡Œã•ã‚Œã€ã‚»ãƒƒã‚·ãƒ§ãƒ³å†…å®¹ã‚’ Obsidian ã«è¨˜éŒ²ã™ã‚‹
 *
 * å‡¦ç†å†…å®¹:
 * 1. transcript ã‹ã‚‰ä¼šè©±å±¥æ­´ã‚’èª­ã¿è¾¼ã¿
 * 2. Claude API ã§ã‚»ãƒƒã‚·ãƒ§ãƒ³è¦ç´„ã‚’ç”Ÿæˆ
 * 3. Obsidian ã®ãƒ‡ã‚¤ãƒªãƒ¼ãƒãƒ¼ãƒˆã«è¿½è¨˜
 * 4. ãƒŠãƒ¬ãƒƒã‚¸ãƒãƒ¼ãƒˆã‚’ä½œæˆï¼ˆã‚³ãƒ¼ãƒ‰ç”ŸæˆãŒã‚ã£ãŸå ´åˆï¼‰
 */

import { readFileSync, existsSync } from "node:fs";
import path from "node:path";
import os from "node:os";
import https from "node:https";
import http from "node:http";

// è¨­å®šèª­ã¿è¾¼ã¿
const configPath = path.join(path.dirname(new URL(import.meta.url).pathname), "config.json");
const config = JSON.parse(readFileSync(configPath, "utf8"));

/**
 * æ—¥ä»˜ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
 */
function formatDate(date, offsetDays = 0) {
  const d = new Date(date);
  d.setDate(d.getDate() + offsetDays);
  return d.toISOString().slice(0, 10);
}

/**
 * ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‹ã‚‰ãƒ‡ã‚¤ãƒªãƒ¼ãƒãƒ¼ãƒˆã‚’ç”Ÿæˆ
 */
function generateDailyNoteFromTemplate(template, date) {
  const dateStr = formatDate(date);
  const prevDate = formatDate(date, -1);
  const nextDate = formatDate(date, 1);

  return template
    .replace(/\{\{DATE:YYYY-MM-DD\}\}/g, dateStr)
    .replace(/\{\{date:YYYY-MM-DD\|offset:-1d\}\}/g, prevDate)
    .replace(/\{\{date:YYYY-MM-DD\|offset:1d\}\}/g, nextDate);
}

/**
 * transcript ã‚’èª­ã¿è¾¼ã‚“ã§ä¼šè©±å†…å®¹ã‚’æŠ½å‡º
 */
function loadTranscript(transcriptPath) {
  const homeDir = os.homedir();
  let resolvedPath = transcriptPath;

  if (transcriptPath.startsWith("~/")) {
    resolvedPath = path.join(homeDir, transcriptPath.slice(2));
  }

  // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯: ~/.claude/projects é…ä¸‹ã®ã¿è¨±å¯
  const allowedBase = path.join(homeDir, ".claude", "projects");
  const absolutePath = path.resolve(resolvedPath);

  if (!absolutePath.startsWith(allowedBase)) {
    throw new Error(`Invalid transcript path: ${transcriptPath}`);
  }

  if (!existsSync(absolutePath)) {
    throw new Error(`Transcript file not found: ${absolutePath}`);
  }

  const lines = readFileSync(absolutePath, "utf8")
    .split("\n")
    .filter(line => line.trim());

  const messages = [];
  for (const line of lines) {
    try {
      const entry = JSON.parse(line);
      if (entry.type === "user" || entry.type === "assistant") {
        messages.push(entry);
      }
    } catch {
      // ç„¡åŠ¹ãªè¡Œã¯ã‚¹ã‚­ãƒƒãƒ—
    }
  }

  return messages;
}

/**
 * ä¼šè©±å†…å®¹ã‚’ãƒ†ã‚­ã‚¹ãƒˆå½¢å¼ã«å¤‰æ›
 */
function formatTranscriptForSummary(messages) {
  const formatted = [];

  for (const msg of messages) {
    const role = msg.type === "user" ? "User" : "Assistant";
    let content = "";

    if (typeof msg.message?.content === "string") {
      content = msg.message.content;
    } else if (Array.isArray(msg.message?.content)) {
      content = msg.message.content
        .filter(c => c.type === "text")
        .map(c => c.text)
        .join("\n");
    }

    if (content) {
      formatted.push(`[${role}]\n${content.slice(0, 2000)}${content.length > 2000 ? "..." : ""}`);
    }
  }

  // æœ€å¤§ãƒˆãƒ¼ã‚¯ãƒ³æ•°ã‚’æŠ‘ãˆã‚‹ãŸã‚ã€æœ€åˆã¨æœ€å¾Œã®éƒ¨åˆ†ã‚’å„ªå…ˆ
  const maxMessages = 20;
  if (formatted.length > maxMessages) {
    const first = formatted.slice(0, 5);
    const last = formatted.slice(-10);
    return [...first, "\n[... ä¸­ç•¥ ...]\n", ...last].join("\n\n");
  }

  return formatted.join("\n\n");
}

/**
 * Ollama API ã«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡
 */
function ollamaRequest(body) {
  return new Promise((resolve, reject) => {
    const ollamaUrl = config.ollama?.baseUrl || "http://localhost:11434";
    const url = new URL("/api/chat", ollamaUrl);

    const options = {
      method: "POST",
      hostname: url.hostname,
      port: url.port,
      path: url.pathname,
      headers: {
        "Content-Type": "application/json"
      }
    };

    const req = http.request(options, (res) => {
      let data = "";
      res.on("data", chunk => data += chunk);
      res.on("end", () => {
        if (res.statusCode >= 200 && res.statusCode < 300) {
          resolve(JSON.parse(data));
        } else {
          reject(new Error(`Ollama API error: ${res.statusCode} - ${data}`));
        }
      });
    });

    req.on("error", reject);
    req.write(JSON.stringify(body));
    req.end();
  });
}

/**
 * Ollama ã§ã‚»ãƒƒã‚·ãƒ§ãƒ³è¦ç´„ã‚’ç”Ÿæˆ
 */
async function generateSummary(transcriptText, cwd) {
  const projectName = path.basename(cwd || "unknown");
  const model = config.ollama?.model || "qwen2.5:7b";

  const prompt = `ä»¥ä¸‹ã® Claude Code ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ä¼šè©±å±¥æ­´ã‚’åˆ†æã—ã¦ã€2ã¤ã®è¦ç´„ã‚’ JSON å½¢å¼ã§ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚

## ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ
${projectName} (${cwd || "ä¸æ˜"})

## ä¼šè©±å±¥æ­´
${transcriptText}

## å‡ºåŠ›å½¢å¼
ä»¥ä¸‹ã® JSON å½¢å¼ã§å‡ºåŠ›ã—ã¦ãã ã•ã„ï¼š

\`\`\`json
{
  "dailyLog": {
    "summary": "ä»Šæ—¥ã®ãƒ‡ã‚¤ãƒªãƒ¼ãƒ­ã‚°ç”¨ã®1-2è¡Œã®ç°¡æ½”ãªè¦ç´„ï¼ˆä½•ã‚’ã—ãŸã‹ï¼‰",
    "tags": ["é–¢é€£ã™ã‚‹ã‚¿ã‚°ï¼ˆ2-3å€‹ï¼‰"]
  },
  "knowledge": {
    "shouldCreate": true/false,
    "title": "ãƒŠãƒ¬ãƒƒã‚¸ãƒãƒ¼ãƒˆã®ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆã‚³ãƒ¼ãƒ‰ç”Ÿæˆã‚„é‡è¦ãªæŠ€è¡“çš„å†…å®¹ãŒã‚ã‚‹å ´åˆï¼‰",
    "content": "ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³å½¢å¼ã®è©³ç´°ãªè§£èª¬ï¼ˆã‚³ãƒ¼ãƒ‰ã®èª¬æ˜ã€å­¦ã‚“ã ã“ã¨ã€æ³¨æ„ç‚¹ãªã©ï¼‰"
  }
}
\`\`\`

ãƒ«ãƒ¼ãƒ«:
- dailyLog.summary ã¯æ—¥æœ¬èªã§ã€ç°¡æ½”ã«ä½œæ¥­å†…å®¹ã‚’è¨˜è¿°
- knowledge.shouldCreate ã¯ã‚³ãƒ¼ãƒ‰ç”Ÿæˆã‚„é‡è¦ãªæŠ€è¡“çš„å†…å®¹ãŒã‚ã‚‹å ´åˆã®ã¿ true
- knowledge.content ã¯ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³å½¢å¼ã§ã€ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚„è¦‹å‡ºã—ã‚’é©åˆ‡ã«ä½¿ç”¨
- JSON ã®ã¿ã‚’å‡ºåŠ›ã—ã€ãã‚Œä»¥å¤–ã®ãƒ†ã‚­ã‚¹ãƒˆã¯å«ã‚ãªã„`;

  const response = await ollamaRequest({
    model,
    messages: [{ role: "user", content: prompt }],
    stream: false
  });

  // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‹ã‚‰JSONã‚’æŠ½å‡º
  const text = response.message?.content || "";

  // ãƒ‡ãƒãƒƒã‚°ç”¨: ç”Ÿã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’å‡ºåŠ›
  if (process.env.DEBUG) {
    console.log("Raw Ollama response:", text);
  }

  // JSON ãƒ–ãƒ­ãƒƒã‚¯ã‚’æŠ½å‡º
  let jsonStr = "";
  const codeBlockMatch = text.match(/```(?:json)?\s*\n?([\s\S]*?)\n?```/);
  if (codeBlockMatch) {
    jsonStr = codeBlockMatch[1].trim();
  } else {
    // ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ãŒãªã„å ´åˆã€{ ã‹ã‚‰ } ã¾ã§ã‚’æŠ½å‡º
    const braceMatch = text.match(/\{[\s\S]*\}/);
    if (braceMatch) {
      jsonStr = braceMatch[0];
    }
  }

  if (!jsonStr) {
    console.error("Failed to extract JSON from response:", text.slice(0, 500));
    throw new Error("Failed to parse summary response: no JSON found");
  }

  // JSON ã‚’ä¿®å¾©ã™ã‚‹è©¦ã¿ï¼ˆã‚ˆãã‚ã‚‹å•é¡Œã‚’ä¿®æ­£ï¼‰
  try {
    return JSON.parse(jsonStr);
  } catch (e) {
    // true/false ã®æ–‡å­—åˆ—ãŒä¸æ­£ãªå ´åˆã®ä¿®æ­£
    jsonStr = jsonStr.replace(/:\s*true\/false/g, ': false');
    // æœ«å°¾ã®ã‚«ãƒ³ãƒã‚’å‰Šé™¤
    jsonStr = jsonStr.replace(/,\s*([\]}])/g, '$1');
    // æ”¹è¡Œã‚’å«ã‚€æ–‡å­—åˆ—å€¤ã‚’ä¿®æ­£
    jsonStr = jsonStr.replace(/:\s*"([^"]*)\n([^"]*)"/g, ': "$1 $2"');

    try {
      return JSON.parse(jsonStr);
    } catch (e2) {
      console.error("JSON parse failed. Attempted to fix:", jsonStr.slice(0, 500));
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æœ€å°é™ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿”ã™
      return {
        dailyLog: {
          summary: "ã‚»ãƒƒã‚·ãƒ§ãƒ³è¦ç´„ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ",
          tags: ["error"]
        },
        knowledge: {
          shouldCreate: false,
          title: "",
          content: ""
        }
      };
    }
  }
}

/**
 * Obsidian REST API ã«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡
 */
function obsidianRequest(method, endpoint, body = null, contentType = "text/markdown") {
  return new Promise((resolve, reject) => {
    const url = new URL(endpoint, config.obsidian.baseUrl);

    const headers = {
      "Authorization": `Bearer ${config.obsidian.apiKey}`
    };

    if (body) {
      headers["Content-Type"] = contentType;
    }

    const options = {
      method,
      hostname: url.hostname,
      port: url.port,
      path: url.pathname + url.search,
      headers,
      rejectUnauthorized: false // è‡ªå·±ç½²åè¨¼æ˜æ›¸ã‚’è¨±å¯
    };

    const req = https.request(options, (res) => {
      let data = "";
      res.on("data", chunk => data += chunk);
      res.on("end", () => {
        if (res.statusCode >= 200 && res.statusCode < 300) {
          resolve({ status: res.statusCode, data });
        } else if (res.statusCode === 404) {
          resolve({ status: 404, data: null });
        } else {
          reject(new Error(`Obsidian API error: ${res.statusCode} - ${data}`));
        }
      });
    });

    req.on("error", reject);

    if (body) {
      req.write(body);
    }
    req.end();
  });
}

/**
 * ãƒ‡ã‚¤ãƒªãƒ¼ãƒãƒ¼ãƒˆã«ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ­ã‚°ã‚’è¿½è¨˜
 */
async function appendToDailyNote(summary, sessionId) {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, "0");
  const date = `${year}-${month}-${String(now.getDate()).padStart(2, "0")}`;

  const dailyNotePath = config.paths.dailyNote
    .replace("{year}", String(year))
    .replace("{month}", month)
    .replace("{date}", date);

  const hour = now.getHours();
  const timePrefix = hour < 12 ? "ğŸŒ…" : hour < 18 ? "ğŸŒ" : "ğŸŒ™";
  const timestamp = `${String(hour).padStart(2, "0")}:${String(now.getMinutes()).padStart(2, "0")}`;
  const tags = summary.dailyLog.tags.map(t => `#${t}`).join(" ");

  const logEntry = `- ${timePrefix} [${timestamp}] Claude Code: ${summary.dailyLog.summary} ${tags}`;

  try {
    // ã¾ãšãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ç¢ºèª
    const checkResult = await obsidianRequest("GET", `/vault/${encodeURIComponent(dailyNotePath)}`);

    if (checkResult.status === 404) {
      // ãƒ‡ã‚¤ãƒªãƒ¼ãƒãƒ¼ãƒˆãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‹ã‚‰ä½œæˆ
      console.log(`Daily note not found, creating from template: ${dailyNotePath}`);
      try {
        const templateResult = await obsidianRequest("GET", `/vault/${encodeURIComponent(config.paths.dailyTemplate)}`);
        if (templateResult.status === 200 && templateResult.data) {
          const newContent = generateDailyNoteFromTemplate(templateResult.data, now);
          await obsidianRequest("PUT", `/vault/${encodeURIComponent(dailyNotePath)}`, newContent);
          console.log(`Daily note created: ${dailyNotePath}`);
        } else {
          console.log(`Template not found, skipping daily note creation`);
          return;
        }
      } catch (templateError) {
        console.error(`Failed to create daily note from template: ${templateError.message}`);
        return;
      }
    }

    // Memo ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«è¿½è¨˜ï¼ˆheading ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ä½¿ç”¨ï¼‰
    const patchEndpoint = `/vault/${encodeURIComponent(dailyNotePath)}`;
    const patchBody = JSON.stringify({
      targetType: "heading",
      target: "Memo",
      operation: "append",
      content: logEntry + "\n"
    });

    await obsidianRequest("PATCH", patchEndpoint, patchBody, "application/json");
    console.log(`Daily note updated: ${dailyNotePath}`);
  } catch (error) {
    // PATCH ãŒå¤±æ•—ã—ãŸå ´åˆã¯ POST ã§æœ«å°¾ã«è¿½è¨˜
    console.log(`PATCH failed, trying POST: ${error.message}`);
    try {
      await obsidianRequest("POST", `/vault/${encodeURIComponent(dailyNotePath)}`, "\n" + logEntry + "\n");
      console.log(`Daily note updated (appended to end): ${dailyNotePath}`);
    } catch (postError) {
      console.error(`Failed to update daily note: ${postError.message}`);
    }
  }
}

/**
 * ãƒŠãƒ¬ãƒƒã‚¸ãƒãƒ¼ãƒˆã‚’ä½œæˆ
 */
async function createKnowledgeNote(summary, sessionId) {
  if (!summary.knowledge.shouldCreate) {
    console.log("No knowledge note needed for this session");
    return;
  }

  const now = new Date();
  const timestamp = now.toISOString().slice(0, 10);
  const safeTitle = summary.knowledge.title
    .replace(/[/\\?%*:|"<>]/g, "-")
    .slice(0, 100);

  const filename = `${timestamp}-${safeTitle}.md`;
  const filepath = `${config.paths.knowledgeBase}/${filename}`;

  const frontmatter = `---
date: "${timestamp}"
session_id: "${sessionId}"
tags:
  - claude-code
${summary.dailyLog.tags.map(t => `  - ${t}`).join("\n")}
---

`;

  const content = frontmatter + summary.knowledge.content;

  try {
    await obsidianRequest("PUT", `/vault/${encodeURIComponent(filepath)}`, content);
    console.log(`Knowledge note created: ${filepath}`);
  } catch (error) {
    console.error(`Failed to create knowledge note: ${error.message}`);
  }
}

/**
 * ãƒ¡ã‚¤ãƒ³å‡¦ç†
 */
async function main() {
  try {
    // ãƒ†ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰
    if (process.argv.includes("--test")) {
      console.log("Test mode: configuration valid");
      console.log(`Obsidian URL: ${config.obsidian.baseUrl}`);
      console.log(`API Key configured: ${config.obsidian.apiKey !== "YOUR_OBSIDIAN_API_KEY_HERE"}`);
      console.log(`Ollama URL: ${config.ollama?.baseUrl || "http://localhost:11434"}`);
      console.log(`Ollama Model: ${config.ollama?.model || "qwen2.5:7b"}`);

      // Ollama æ¥ç¶šãƒ†ã‚¹ãƒˆ
      try {
        const testResponse = await ollamaRequest({
          model: config.ollama?.model || "qwen2.5:7b",
          messages: [{ role: "user", content: "Hello" }],
          stream: false
        });
        console.log(`Ollama connection: OK`);
      } catch (e) {
        console.log(`Ollama connection: FAILED - ${e.message}`);
      }

      process.exit(0);
    }

    // ãƒ•ãƒƒã‚¯å…¥åŠ›ã‚’èª­ã¿è¾¼ã¿
    const input = JSON.parse(readFileSync(process.stdin.fd, "utf8"));

    if (!input.transcript_path) {
      console.log("No transcript path provided");
      process.exit(0);
    }

    // ä¼šè©±å±¥æ­´ã‚’èª­ã¿è¾¼ã¿
    const messages = loadTranscript(input.transcript_path);

    if (messages.length < 2) {
      console.log("Session too short to log");
      process.exit(0);
    }

    // ãƒ†ã‚­ã‚¹ãƒˆå½¢å¼ã«å¤‰æ›
    const transcriptText = formatTranscriptForSummary(messages);

    // è¦ç´„ã‚’ç”Ÿæˆ
    console.log("Generating session summary...");
    const summary = await generateSummary(transcriptText, input.cwd);

    // Obsidian ã«è¨˜éŒ²
    await appendToDailyNote(summary, input.session_id);
    await createKnowledgeNote(summary, input.session_id);

    console.log("Session logged successfully");
  } catch (error) {
    console.error(`Session logger error: ${error.message}`);
    process.exit(1);
  }
}

main();
